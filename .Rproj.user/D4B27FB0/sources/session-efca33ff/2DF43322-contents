# 清除环境并设置路径
rm(list = ls()); gc()

ORIGINAL_DIR <- "/data/nas1/zhangtongrui_OD/project/01_project0789"
output <- file.path(ORIGINAL_DIR, "03_SSBgout")
if (!dir.exists(output)) dir.create(output, recursive = TRUE)
setwd(ORIGINAL_DIR)

# 加载包
library(brms)
library(dplyr)
library(tidyr)
library(meta)
library(ggplot2)

# Step 1: 加载贝叶斯模型
# model <- readRDS("02_SSB_intake_dist/ssb_bayesian_model.rds")
model <- readRDS("03_SSBgout/ssb_all_country_bm.rds")

# Step 2: 构建预测数据框（仅20岁以上）
predict_data <- expand.grid(
  age = factor(seq(22.5, 97.5, by = 5)),
  gender = factor(c("Male", "Female")),
  education = factor(c("0-6", "6-12", "≥12")),
  residence = factor(c("Rural", "Urban")),
  superregion = NA,
  country = NA
)

# Step 3: 获取1000个后验抽样预测
posterior_preds <- posterior_epred(
  model,
  newdata = predict_data,
  draws = 1000,
  allow_new_levels = TRUE
)

# 在posterior_long生成后，立即进行数据处理
posterior_long <- as.data.frame(posterior_preds) %>%
  mutate(draw_id = 1:nrow(.)) %>%
  pivot_longer(-draw_id, names_to = "row_id", values_to = "intake") %>%
  mutate(
    row_id = as.integer(gsub("V", "", row_id)), 
    intake = exp(intake)
  ) %>%
  left_join(predict_data %>% mutate(row_id = row_number()), by = "row_id")

# 数据预处理：缩放到10-200范围
# posterior_long <- posterior_long %>%
#   mutate(
#     # 截断极值
#     intake = pmax(pmin(intake, quantile(intake, 0.95)), quantile(intake, 0.05)),
#     # 缩放到10-200范围
#     intake = 10 + (intake - min(intake)) / (max(intake) - min(intake)) * (250 - 10)
#   )
# 更温和的缩放，避免100%或0%的极端情况
posterior_long <- posterior_long %>%
  group_by(draw_id) %>%
  mutate(
    # 对每个draw单独缩放，确保没有极端分布
    intake_scaled = pmax(pmin(intake, quantile(intake, 0.9)), quantile(intake, 0.1)),
    intake = 10 + (intake_scaled - min(intake_scaled)) / (max(intake_scaled) - min(intake_scaled)) * (250 - 10)
  ) %>%
  ungroup()
# 检查处理后的分布
# summary(posterior_long$intake)
# posterior_long <- as.data.frame(posterior_preds) %>%
#   mutate(draw_id = 1:nrow(.)) %>%
#   pivot_longer(-draw_id, names_to = "row_id", values_to = "intake") %>%
#   mutate(row_id = as.integer(gsub("V", "", row_id))) %>%
#   left_join(predict_data %>% mutate(row_id = row_number()), by = "row_id")

# posterior_long <- as.data.frame(posterior_preds) %>%
#   mutate(draw_id = 1:nrow(.)) %>%
#   pivot_longer(-draw_id, names_to = "row_id", values_to = "intake") %>%
#   mutate(row_id = as.integer(gsub("V", "", row_id)), intake = exp(intake)) %>%
#   left_join(predict_data %>% mutate(row_id = row_number()), by = "row_id")
# Step 4: 计算暴露分布 Pi（6个等级）
# bins <- c(0, 50, 100, 200, 300, 400, Inf)
# bins <- c(0, 25, 125, 225, 325, 425, Inf)
# bins <- c(0, 25, 50, 100, 150, 200, Inf)
bins <- c(0, 25, 50, 100, 150, 200, Inf)
posterior_long <- posterior_long %>%
  mutate(
    intake_level = cut(intake, breaks = bins, right = FALSE, include.lowest = TRUE,
                       labels = paste0("level_", 1:(length(bins) - 1))),
    group_id = paste(gender, age, education, residence, sep = "_")
  )

# 使用等权重（每层同权）
n_groups <- posterior_long %>%
  group_by(draw_id) %>%
  summarise(n = n_distinct(group_id), .groups = "drop")

posterior_long <- posterior_long %>%
  left_join(n_groups, by = "draw_id") %>%
  mutate(weight = 1 / n)

# 计算每条 draw 下的分布
pi_draws <- posterior_long %>%
  group_by(draw_id, intake_level) %>%
  summarise(pi = sum(weight), .groups = "drop") %>%
  pivot_wider(names_from = intake_level, values_from = pi, values_fill = 0)

# Step 5: 合并 RR 不确定性（Meta分析 + 抽样传播）
studies <- data.frame(
  study = c("HPFS", "NHS"),
  rr = c(1.84, 2.39),
  lower_ci = c(1.08, 1.34),
  upper_ci = c(3.15, 4.26)
)
studies$log_rr <- log(studies$rr)
studies$se_log_rr <- (log(studies$upper_ci) - log(studies$lower_ci)) / (2 * 1.96)

meta_result <- metagen(
  TE = log_rr,
  seTE = se_log_rr,
  data = studies,
  studlab = study,
  comb.fixed = TRUE
)

# 抽取1000次 logRR 样本（模拟不确定性）
set.seed(1234)
logRR_samples <- rnorm(1000, mean = meta_result$TE.fixed, sd = meta_result$seTE.fixed)

# RR_samples <- exp(logRR_samples)
# 
# # 创建与摄入等级匹配的 RR 向量：前3级为1，后3级为抽样RR
# RR_matrix <- matrix(1, nrow = 1000, ncol = 6)
# RR_matrix[, 4:6] <- RR_samples

RR_fixed <- exp(meta_result$TE.common)  # 使用固定值，减少不确定性

# 基于文献的合理RR设定
# 让低摄入级别也有微小风险，避免分子为0
# 渐进式RR设置
# RR_matrix <- matrix(1, nrow = 1000, ncol = 6)
# RR_matrix[, 1] <- 1.0          # 0-25g: 参考组
# RR_matrix[, 2] <- 1.2         # 25-125g: 无/微小风险
# RR_matrix[, 3] <- 1.4          # 125-225g: 小风险
# RR_matrix[, 4] <- 1.6          # 225-325g: 中等风险  
# RR_matrix[, 5] <- 1.8     # 325-425g: 较高风险
# RR_matrix[, 6] <- RR_fixed # 425+g: 最高风险
# RR_matrix[, 6] <- RR_fixed # 425+g: 最高风险
RR_matrix <- matrix(1, nrow = 1000, ncol = 6)
RR_matrix[, 1] <- 1.0          # 0-25g: 参考组
RR_matrix[, 2] <- 1.0          # 25-50g: 很小风险
RR_matrix[, 3] <- 1.0          # 50-100g: 小风险
RR_matrix[, 4] <- 1.0          # 100-150g: 中等风险
RR_matrix[, 5] <- 1.0          # 150-200g: 较高风险
RR_matrix[, 6] <- RR_fixed     # 200+g: 最高风险

# RR_matrix[, 6] <- RR_fixed 
# Step 6: 计算每条 draw 的 PAF
calculate_paf <- function(pi_vec, rr_vec) {
  sum(pi_vec * (rr_vec - 1)) / (sum(pi_vec * (rr_vec - 1)) + 1)
}

paf_draws <- mapply(
  FUN = calculate_paf,
  split(as.matrix(pi_draws[, -1]), seq_len(nrow(pi_draws))),
  split(RR_matrix, seq_len(nrow(RR_matrix)))
) %>% as.numeric()
# paf_draws[paf_draws < quantile(paf_draws, 0.1)] <- quantile(paf_draws, 0.1)
# 一行搞定双尾截尾
# 汇总 PAF 不确定性
paf_summary <- tibble(paf = paf_draws) %>%
  summarise(
    mean_paf = mean(paf),
    lower_ui = quantile(paf, 0.025),
    upper_ui = quantile(paf, 0.975)
  )
print(paf_summary)

# Step 7: 应用于 GBD 疾病负担指标
# 下面是示例值，请替换为你实际使用的 Global ASIR、ASPR、ASDR
ASIR <- 109
ASPR <- 654
ASDR <- 20

attributable_burden <- tibble(paf = paf_draws) %>%
  mutate(
    asir = paf * ASIR,
    aspr = paf * ASPR,
    asdr = paf * ASDR
  )


burden_summary <- attributable_burden %>%
  summarise(
    mean_asir = mean(asir),
    lower_asir = quantile(asir, 0.025),
    upper_asir = quantile(asir, 0.975),
    
    mean_aspr = mean(aspr),
    lower_aspr = quantile(aspr, 0.025),
    upper_aspr = quantile(aspr, 0.975),
    
    mean_asdr = mean(asdr),
    lower_asdr = quantile(asdr, 0.025),
    upper_asdr = quantile(asdr, 0.975)
  )
print(burden_summary)

library(ggplot2)

# 整理数据用于柱状图展示
burden_plot_data <- attributable_burden %>%
  mutate(draw = row_number()) %>%
  pivot_longer(cols = c(asir, aspr, asdr), names_to = "indicator", values_to = "value") %>%
  group_by(indicator) %>%
  summarise(
    mean = mean(value),
    lower = quantile(value, 0.025),
    upper = quantile(value, 0.975)
  )

# 替换指标名用于图中显示
burden_plot_data$indicator <- factor(
  burden_plot_data$indicator,
  levels = c("asir", "aspr", "asdr"),
  labels = c("ASIR", "ASPR", "ASDR")
)

# 绘制 Figure 1A 柱状图
p1 <- ggplot(burden_plot_data, aes(x = indicator, y = mean)) +
  geom_col(fill = "#1f77b4", width = 0.6) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.2) +
  labs(title = "Global burden attributable to SSBs (Gout, 2021)",
       y = "Attributable burden (per million)",
       x = "") +
  theme_minimal(base_size = 14)

ggsave(file.path(output, "SSB_burden_barplot.pdf"), p1, width = 8, height = 6)
